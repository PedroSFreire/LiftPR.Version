#version 460
#extension GL_GOOGLE_include_directive : require
#extension GL_EXT_ray_tracing : require

#include "utils/random.glsl"
#include "utils/material.glsl"
#include "utils/ray_payload.glsl"
#include "utils/uniform_buffer_object.glsl"
#include "utils/tone_mapping.glsl"

layout(binding = 0, set = 0) uniform accelerationStructureEXT scene_;
layout(binding = 1, rgba32f) uniform image2D output_image_;
layout(binding = 2, rgba32f) uniform image2D accumulation_image_;
layout(binding = 3) readonly uniform UniformBufferObjectStruct { UniformBufferObject ubo_; };
layout(binding = 7) readonly buffer LightArray { Light[] lights_; };

layout(location = 0) rayPayloadEXT RayPayload ray_;
layout(location = 2) rayPayloadEXT bool shadow_ray_;

#include "utils/sampling.glsl"

struct LightPathNode {
    vec3 color;
    vec3 position;
    vec3 normal;
    
    float dVCM;
    float dVM;
    float dVC;

    bool specular;
};

#define LIGHTPATHLENGTH 5
#define PI 3.14159265359f
//#define RAIO 0.006f
#define RAIO 0.025f
//#define RAIO 1.0f
LightPathNode[LIGHTPATHLENGTH] light_paths_;
vec3 lightSourcePos;

//-----------------------------------------------------
// lightpath
//-----------------------------------------------------

void constructLightPath(inout uint seed) {
    float raio = RAIO/pow(ubo_.number_of_samples,0.5*RAIO); 
    uint ray_flags = gl_RayFlagsOpaqueNV;
    uint cullMask = 0xff;
    float tmin = 0.001;
    float tmax = 10000.0;
    float pdf = 1.0f;
    float etaVcm =PI*raio*raio/* *number_of_lights */;
    float refPdf = 0.0f;
    float specChance = 0.0f;
    float diffChance = 0.0f;
    float costheta = 0.0f;


    Light light = lights_[0];

    vec3 ro = light.corner.xyz + light.v1.xyz * randomFloat(seed) + light.v2.xyz * randomFloat(seed);
    vec3 rd = vec3(light.normal.x + randomFloat(seed), light.normal.y + randomFloat(seed), light.normal.z + randomFloat(seed));
    float emissionPdf = rd.z / PI;
    rd = normalize(rd);
    lightSourcePos = ro;

    vec3 color = light.emission.xyz ;
    //color *= max(emissionPdf, 0.000001f);
    for (int i = 0; i < LIGHTPATHLENGTH; i++) {
        light_paths_[i].position = light_paths_[i].color = light_paths_[i].normal = vec3(0.0);
        light_paths_[i].dVCM = light_paths_[i].dVC =  light_paths_[i].dVM = 0.0;
        light_paths_[i].specular = false;
    }
    float directPdf = 2.0 / length(cross(light.v1.xyz, light.v2.xyz)) /*number_of_lights*/ ;
    emissionPdf *= directPdf;
    light_paths_[0].dVCM = directPdf / emissionPdf;
    light_paths_[0].dVC = sqrt(rd.y) / emissionPdf;
    light_paths_[0].dVM = light_paths_[0].dVC /etaVcm;

    bool specular_bounce = false;

    for (int i = 0; i < LIGHTPATHLENGTH; i++) {
        ray_.t = tmax;
        ray_.mat = getZeroedMaterial();
        ray_.missed = false;
        ray_.from_inside = false;
        traceRayEXT(scene_, ray_flags, cullMask, 0, 0, 0, ro, tmin, rd, tmax, 0);

        if (ray_.missed) {
            break;
        }

        if (dot(rd, ray_.normal) < 0.0) {

            light_paths_[i].position = ro;
            light_paths_[i].normal = ray_.normal;
            if(i>0){
            light_paths_[i].dVCM *= sqrt(length(ro-light_paths_[i-1].position));
            }
            light_paths_[i].dVCM /= dot(-rd,ray_.normal);
            light_paths_[i].dVM /= dot(-rd,ray_.normal);
            light_paths_[i].dVC /= dot(-rd,ray_.normal);
            if (!specular_bounce) {
                light_paths_[i].color = color;
            }
            else{
            light_paths_[i].specular = true;
            }


            sampleBRDF(rd, ro, color, specular_bounce, seed, pdf, specChance, diffChance);
            costheta = max(0.0f, dot(ray_.normal, rd)); 
            refPdf = (dot(-rd,ray_.normal)/PI)*diffChance + specChance*((ray_.mat.specular_roughness+1)*pow(costheta,ray_.mat.specular_roughness)*(0.5f/PI));
            if(i+1<LIGHTPATHLENGTH){
            light_paths_[i+1].dVCM = 1/pdf;
            light_paths_[i+1].dVM = (rd.z/pdf) * (light_paths_[i].dVM *refPdf + light_paths_[i].dVCM * (1/etaVcm) + 1.0f);
            light_paths_[i+1].dVC = (rd.z/pdf) * (light_paths_[i].dVC *refPdf + light_paths_[i].dVCM + etaVcm);
            }
        }

    }

}

//-----------------------------------------------------
// eyepath
//-----------------------------------------------------

float getWeightForPath(int s, int t) {
    return float(s + t + 2);
}

vec3 traceEyePath(in vec3 ro, in vec3 rd, inout uint seed) {
    float raio = RAIO/pow(ubo_.number_of_samples,0.5*RAIO); 
    uint ray_flags = gl_RayFlagsOpaqueNV;
    uint cullMask = 0xff;
    float tmin = 0.001;
    float tmax = 10000.0;
    vec3 prevRo = ro;
    float pdf = 1.0f;
    float etaVcm =PI*raio*raio/* *number_of_lights */;
    float refPdf = 0.0f;
    float specChance = 0.0f;
    float diffChance = 0.0f;
    float costheta = 0.0f;
    float dVCM = 0.0f;
    float dVC = 0.0f;
    float dVM = 0.0f;
    float cosAtCamera = dot(vec3(ubo_.x,ubo_.y,ubo_.z),rd );
    float imagePointToCameraDist = (imageSize(output_image_).x / (2 * tan(ubo_.fov*PI/360))) / cosAtCamera;
    dVCM = sqrt(imagePointToCameraDist) / cosAtCamera;

    float Raio2 = raio*raio;
    float vmNormalization = 1.0f / (PI * Raio2);
    float vmWeight = PI * Raio2; //1 = VCcount = Vmcount; so um light path de onde escolher
    float vcWeight = 1.0f / (PI * Raio2); //1 = VCcount = Vmcount; so um light path de onde escolher
 
    vec3 tcol = vec3(0.0);
    vec3 fcol = vec3(1.0);

    int jdiff = 0;
    bool specular_bounce = true;

    for (int j = 0; j < ubo_.number_of_bounces; j++) {
        // shoot a ray out into the world
        ray_.t = tmax;
        ray_.mat = getZeroedMaterial();
        ray_.missed = false;
        ray_.from_inside = false;
        traceRayEXT(scene_, ray_flags, cullMask, 0, 0, 0, ro, tmin, rd, tmax, 0);
        dVCM *= sqrt(length(ro-prevRo));
        dVCM /= dot(-rd,ray_.normal);
        dVC /= dot(-rd,ray_.normal);
        dVM /= dot(-rd,ray_.normal);

        if (ray_.mat.emissive != vec3(0.0)) {
            if(specular_bounce) {
                tcol += fcol * ray_.mat.emissive;
            }
            return tcol;
        }

        sampleBRDF(rd, ro, fcol, specular_bounce, seed, pdf, specChance, diffChance);
        prevRo = ro;

        costheta = max(0.0f, dot(ray_.normal, rd)); 
        refPdf = (dot(-rd,ray_.normal)/PI)*diffChance + specChance*((ray_.mat.specular_roughness+1)*pow(costheta,ray_.mat.specular_roughness)*(0.5f/PI));
        dVCM = 1/pdf;
        dVM = (rd.z/pdf) * (dVM *refPdf + dVCM * (1/etaVcm) + 1.0f);
        dVC = (rd.z/pdf) * (dVC *refPdf + dVCM + etaVcm);


        if (ray_.missed) {
            return tcol;
        }

        if(ubo_.debug_normals) {
            return remap(ray_.normal, -1.0f, 1.0f, 0.0f, 1.0f);
        }
        // VERTEX CONNECTION TO LIGHT SOURCE
        vec3 lSourced;
        float lSourceweight, lightSource_dist;
        sampleLight(ro, lSourced, lightSource_dist, lSourceweight, seed);
        costheta = dot(ray_.normal, lSourced);
        float bsdfDirPdfw = diffChance*max(0.0f, costheta / PI) + specChance*((ray_.mat.specular_roughness+1)*pow(costheta,ray_.mat.specular_roughness)*(0.5f/PI));
        //float  algo de VC to light source 

        //misWeight = 1.0f/(wLight+1+wCamera);
        //tcol += fcol *  ((misWeight * cosToLight / (lightPickProb * directPdfw)) * radiance * bsdfFactor)
        //VERTEX MERGING
        /*
        vec3 ld;
        float weight, light_dist;
        float dist;
        vec3 accum = vec3(0.0);
        sampleLight(ro, ld, light_dist, weight, seed);
        for(int i=0; i < LIGHTPATHLENGTH; i++){
            dist = length( light_paths_[i].position - ro);
            dist = dist*dist;
            if(dist <= Raio2)
                accum += light_paths_[i].color;// * ( 1 / ( 1 + light_paths_[i].dVCM * light_paths_[i].dVM + dVCM*dVM ));
        }
        tcol += fcol * accum * vmNormalization;
        */
        //VERTEC CONNECTION 
        int random = randomInt(seed, 0, LIGHTPATHLENGTH-1);
        vec3 ldist = light_paths_[random].position -ro;
        vec3 ldistn = normalize(ldist);
        vec3 lcolor = light_paths_[random].color;
        if (!isOccluded(ro, ldistn, length(ldist))){
            tcol += fcol * lcolor;
        }

        jdiff = !specular_bounce ? jdiff + 1 : 0;

        // Russian Roulette
        float p = max(fcol.r, max(fcol.g, fcol.b));
        if (randomFloat(seed) > p) {
            break;
        }
        fcol *= 1.0f/p;
    }

    return tcol;
}

void main() {
    vec3 pixel_color = vec3(0);

    for (int curr_sample = 0; curr_sample < ubo_.number_of_samples; curr_sample++) {
        uint seed = initRandom(gl_LaunchIDEXT.xy, ubo_.seed + ubo_.frame + curr_sample);

        const vec2 jitter = vec2(randomFloat(seed), randomFloat(seed)) - 0.5f;
        const vec2 uv_jittered = (gl_LaunchIDEXT.xy + jitter) / vec2(gl_LaunchSizeEXT.xy);
        const vec2 screen = uv_jittered * 2.0 - 1.0;

        vec4 origin = ubo_.model_view_inverse * vec4(0, 0, 0, 1);
        vec4 target = ubo_.projection_inverse * vec4(screen.x, screen.y, 1, 1);
        vec4 direction = ubo_.model_view_inverse * vec4(normalize(target.xyz), 0);

        constructLightPath(seed);

        pixel_color += traceEyePath(origin.xyz, direction.xyz, seed);
    }

    pixel_color /= float(ubo_.number_of_samples);

    vec4 last_frame_color = imageLoad(accumulation_image_, ivec2(gl_LaunchIDEXT.xy));
    float blend = (ubo_.frame < 2 || last_frame_color.a == 0.0) ? 1.0f : 1.0f / (1.0f + (1.0f / last_frame_color.a));
    pixel_color = mix(last_frame_color.rgb, pixel_color, blend);

    imageStore(accumulation_image_, ivec2(gl_LaunchIDEXT.xy), vec4(pixel_color, blend));

    // post processing
    pixel_color *= ubo_.exposure;

    if (ubo_.tone_map) {
        pixel_color = ACESFilm(pixel_color);
    }

    if (ubo_.gamma_correction) {
        pixel_color = linearToSRGB(pixel_color);
    }

    imageStore(output_image_, ivec2(gl_LaunchIDEXT.xy), vec4(pixel_color, blend));
}
